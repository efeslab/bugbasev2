#!# #############################################
#!# # environment variables can be overridden
#!# #############################################
#!# ER_ROOT: the root dir of ER's repository (default is /ER)
#!# BUGBASE_ROOT: the root dir of bugbasev2 repository
#!#   (default is ${ER_ROOT}/third-party/bugbasev2)
#!# OVERWRITE: whether overwrite existing record/replay directory (default is 0)
#!# EXTRA_KLEE_ARGS: optional extra args (default is empty)
#!# FULLY_REPLAYED: a replay.%.klee-out dir which has an empty "fully_replayed" file
#!#   (default is to auto find a such dir)
#!# TESTCASE: the name of the testcase generated by klee (default is test000001)
#!# ENABLETIMEOUT: enable solver timeout detection (default is 1, set 0 to disable)
#!# REPORT_INTERVAL: how frequent (unit is second) KLEE reports internal status. (default is 300)

# variables expected to be defined before including this file
## ALL_BC: all required .bc files
## KLEE_BC: the bitcode file to run klee on
## INPUT_FILES: a list of files specify the input files of an application
## APP_ARGS: the args passed to the program to trigger the failure. This should
##    be a Makefile function var which takes a ${INPUT_FILES} like string as
##    argument. The argument could also be input files generated by ER.
## KLEE_ARGS: the application specific args for both record and replay process
## POSIX_ARGS: the args passed to the posix runtime for both record and replay (e.g. overwrite argv[0])
## REPLAY_POSIX_ARGS: the args passed to the posix runtime during replay (e.g. define symbolic files)
## ELF_APP: the elf binary to observe the application failure natively
# variables can be overridden by each application's Makefile:
## ENVFILE=%FILE
## SOLVER={stp,z3}
## ORACLE_KTEST=%FILE


###############################################################################
SHELL=/bin/bash
.DEFAULT_GOAL := help

#####################################
# Intermediate file configuration
#####################################
DATAREC_CFG_DIR?=config
BITCODE_DIR?=bitcode
AUTO_MKDIR:= ${DATAREC_CFG_DIR} ${BITCODE_DIR}
BCNAME:=$(basename ${KLEE_BC})
####################################
# klee options configuration
####################################
SOLVER?=stp
ENVFILE?=emptyenv
ORACLE_KTEST?=oracle.ktest
SOLVERTIMEOUT?=30s
ENABLETIMEOUT?=1
KLEE_CMD:=ulimit -s unlimited; klee
KLEE_ARGS+=-solver-backend=${SOLVER} -use-forked-solver=false
KLEE_ARGS+=-output-stats=false -output-istats=false -output-source=false \
  -write-kqueries -write-paths --libc=uclibc --posix-runtime \
  -env-file=${ENVFILE} -pathrec-entry-point="__klee_posix_wrapped_main" \
  -ignore-posix-path=true -use-independent-solver=true -oob-check=true \
  -allocate-determ -call-solver=false ${EXTRA_KLEE_ARGS}
# oracle.ktest is used to verify the correctness of constraints
# ER does not infer any information from the oracle
KLEE_REPLAY_ARGS+=\
  -kinst-binding=lesscost -monolithic -simplify-sym-indices=true
ifeq (${ENABLETIMEOUT},1)
  KLEE_REPLAY_ARGS+=-max-solver-time=${SOLVERTIMEOUT}
endif
ifneq (${REPORT_INTERVAL},)
  KLEE_REPLAY_ARGS+=--report-interval=${REPORT_INTERVAL}
endif
######################################
# General configuration
######################################
ER_ROOT?=/ER
BUGBASE_ROOT?=${ER_ROOT}/third-party/bugbasev2
OVERWRITE?=0
export HASE_PY=${ER_ROOT}/utils/visualize/hase.py
ANALYZE=${BUGBASE_ROOT}/utils/analyze.sh
TESTCASE?=test000001

# klee has to take the same bitcode path across record and replay (because the
# program may make use of argv[0] and ER does not model symbolic commandline).
# The ${RUNTIME_BC} is a temporary file updated every iteration
RUNTIME_BC:=${BITCODE_DIR}/run.bc

#!# #############################################
#!# # Misc options
#!# #############################################
.PHONY: help all-bc build-clean er-clean clean
#!# help: display this help message
help:
	@sed -n 's/^#!# //p' ${MAKEFILE_LIST}
# prevent removing intermediate files
.SECONDARY:
# disable automatic suffix check
.SUFFIXES:
#!# all-bc: build the LLVM IR bitcode of an application
all-bc: ${ALL_BC}
#!# build-clean: only clean bitcodes and application-specific compilation
#!# er-clean: clean files generated by all iterations.
er-clean:
	-rm -rf ${BITCODE_DIR} ${DATAREC_CFG_DIR} record.*.klee-out replay.*.klee-out
#!# clean: both build-clean and er-clean
clean: build-clean er-clean

#!# #############################################
#!# # The iterative process
#!# #############################################
${ENVFILE}:
	touch $@
${AUTO_MKDIR}:
	mkdir $@
${DATAREC_CFG_DIR}/datarec.1.cfg: ${DATAREC_CFG_DIR}
	touch $@
${BITCODE_DIR}/${BCNAME}.%.bc: ${DATAREC_CFG_DIR}/datarec.%.cfg ${BITCODE_DIR} ${KLEE_BC}
	prepass -assign-id -insert-ptwrite \
    -ptwrite-cfg=$< ${KLEE_BC} $@
define check-dir =
@if [ -d $@ ]; then \
  if [ ${OVERWRITE} -eq "0" ]; then \
    echo "$@ already exists, do not overwrite"; \
    exit -1; \
  else \
    rm -rf $@; \
  fi \
fi
endef
#!# record.$i.klee-out: start the $i-th iteration by recording a failure using
#!#   configuration generated from previous iteration. 1st iteration will use an
#!#   empty recording configuration. $i has to be an integer.
record.%.klee-out: ${BITCODE_DIR}/${BCNAME}.%.bc ${ENVFILE}
	$(check-dir)
	$(eval KLEE_RECORD_ARGS+=${KLEE_ARGS} \
	  -save-final-module-path=${BITCODE_DIR}/freq.${BCNAME}.$*.bc -output-dir=$@)
	cp $< ${RUNTIME_BC}
	${KLEE_CMD} ${KLEE_RECORD_ARGS} ${RUNTIME_BC} ${POSIX_ARGS} $(call APP_ARGS, ${INPUT_FILES})

#!# replay.$i.klee-out: symbolically replay the recorded $i-th iteration by
#!#   assuming all inputs are unknown. $i has to be an integer.
replay.%.klee-out: ${BITCODE_DIR}/freq.${BCNAME}.%.bc record.%.klee-out/${TESTCASE}.path ${ENVFILE} ${ORACLE_KTEST}
	$(check-dir)
	$(eval RECORD_PATH:=$(word 2, $^))
	$(eval KLEE_REPLAY_ARGS+=${KLEE_ARGS} -oracle-KTest=${ORACLE_KTEST} \
	  -replay-path=${RECORD_PATH} -output-dir=$@)
	cp $< ${RUNTIME_BC}
	${KLEE_CMD} ${KLEE_REPLAY_ARGS} ${RUNTIME_BC} ${POSIX_ARGS} ${REPLAY_POSIX_ARGS} $(call APP_ARGS, ${INPUT_FILES}) ${REPLAY_ARGS}

.SECONDEXPANSION:
# secondary expansion, to enable the $$(shell echo $$$$(($$*-1))) trick
replay.%.klee-out/newdatarec.cfg: ${BITCODE_DIR}/freq.${BCNAME}.%.bc replay.%.klee-out
	${ANALYZE} $< $(realpath $(dir $@)) $@
	@ret=$$?; if [ $$ret -ne 0 ]; then \
	  exit $$ret; \
	fi
replay.%.klee-out/checkdatarec.cfg: ${BITCODE_DIR}/freq.${BCNAME}.%.bc FORCE
	INTERMEDIATE_SUFFIX=".check" ${ANALYZE} $< $(realpath $(dir $@)) $@
	@ret=$$?; case $$ret in \
	  0) diff -u $@ $(subst checkdatarec,newdatarec,$@) ;;\
	  1) echo "skip" ;;\
	  *) exit $$ret ;;\
	esac
	@rm $@
${DATAREC_CFG_DIR}/datarec.%.cfg: replay.$$(shell echo $$$$(($$*-1))).klee-out/newdatarec.cfg ${DATAREC_CFG_DIR}
	@cat ${DATAREC_CFG_DIR}/datarec.$$(($*-1)).cfg $< > $@

# external generated file warning
${BITCODE_DIR}/freq.${BCNAME}.%.bc record.%.klee-out/${TESTCASE}.path:
	@echo "You should run make record.$*.klee-out first"
	@exit -1

#!# #############################################
#!# # Failure Reproduction
#!# #############################################
.PHONY: elf-fail
#!# elf-fail: observe the application failure with native binary and oracle inputs
elf-fail: ${ELF_APP} ${INPUT_FILES}
	${ELF_APP} $(call APP_ARGS, ${INPUT_FILES})
.PHONY: elf-fail-er
#!# elf-fail-er: observe the application failure with native binary and
#!#   er-generated inputs. (Must have a fully replayed dir)
#!# record.check.klee-out: observe the application failure with klee recording
#!#   and er-generated inputs. (Must have a fully replayed dir)
#!# verify: compare the control flow trace between
#!#   1. record.check.klee-out (using er-generated input) and
#!#   2. record.1.klee-out (using oracle input)
#!# compare: show the path of oracle inputs and generated inputs for manual
#!#   inspection
FULLY_REPLAYED?=$(subst /fully_replayed,,\
  $(word 1, $(wildcard replay.*.klee-out/fully_replayed)))

ifneq ($(strip ${FULLY_REPLAYED}),)
getGeneratedFile=${FULLY_REPLAYED}/${TESTCASE}.ktest.$(1)
ER_GENERATED_INPUT:=$(foreach inputfile, ${INPUT_FILES}, \
  $(call getGeneratedFile,$(inputfile)))
elf-fail-er: ${ELF_APP} ${ER_GENERATED_INPUT}
	${ELF_APP} $(call APP_ARGS, ${ER_GENERATED_INPUT})
${FULLY_REPLAYED}/${TESTCASE}.ktest.%: ${FULLY_REPLAYED}/${TESTCASE}.ktest
	ktest-tool --extract $* $<
verify: record.1.klee-out/${TESTCASE}.path record.check.klee-out
	@echo "##########################################################"
	@echo "## Checking whether ER reproduce the same control flow: ##"
	@echo "##########################################################"
	@pathviewer -dump $(word 1, $^) > oracle.path.log
	@pathviewer -dump record.check.klee-out/${TESTCASE}.path > er.path.log
	@if diff -u oracle.path.log er.path.log; then \
	   echo "Same control flow verified"; \
	 fi
	@rm -rf oracle.path.log er.path.log
record.check.klee-out: ${BITCODE_DIR}/${BCNAME}.1.bc ${ENVFILE} ${ER_GENERATED_INPUT}
	@rm -rf $@
	$(eval KLEE_RECORD_ARGS+=${KLEE_ARGS} -output-dir=$@)
	$(eval KLEE_REMAP_INPUTS_ARGS:=$(foreach inputfile, ${INPUT_FILES}, \
	-remap-file $(inputfile) $(call getGeneratedFile,$(inputfile))))
	cp $< ${RUNTIME_BC}
	${KLEE_CMD} ${KLEE_RECORD_ARGS} ${RUNTIME_BC} ${POSIX_ARGS} \
	  $(call APP_ARGS, ${INPUT_FILES}) ${KLEE_REMAP_INPUTS_ARGS}
compare: ${ER_GENERATED_INPUT}
	@echo "##########################################################"
	@echo "## You can manually compare the following input files:  ##"
	@echo "##########################################################"
	@echo "Format: oracle input file | er-generated input file"
	@echo -e $(foreach inputfile, ${INPUT_FILES}, \
	  \\t$(inputfile) \| $(call getGeneratedFile,$(inputfile)\\n))

else # of ${FULLY_REPLAYED}
elf-fail-er verify compare:
	@echo "Cannot find a fully replayed directory"

endif # end of ${FULLY_REPLAYED}
#!# #############################################
#!# # Report Statistics
#!# #############################################
.PHONY: reportheader reporttime reportiter report
reportheader:
	@echo "#######################"
	@echo "## Report Statistics ##"
	@echo "#######################"
#!# reportiter: report total number of iterations until fully symbolic replay
reportiter:
	@echo "Total iteration: $(patsubst replay.%.klee-out,%,${FULLY_REPLAYED})"
#!# reporttime: report total time spent in symbolic execution of all iterations
reporttime:
	@cat $(addsuffix /messages.txt, $(wildcard replay.*.klee-out)) | \
	  awk 'BEGIN {FS=":"}; /.*In-engine time.*/ {sum+=$$3;} END{print "Total seconds: "sum}'
#!# report: report all above statistics
report: | reportheader reportiter reporttime
#!# #############################################
#!# # For Debugging
#!# #############################################
.PHONY: check-cfg
#!# check-cfg: help you verify existing data recording configuration remain
#!#   unchanged when graph analysis algorithm is changeg
check-cfg: $(subst newdatarec,checkdatarec,$(wildcard replay.*.klee-out/newdatarec.cfg))

# FORCE is the trick to make pattern matched implicit rule .PHONY
.PHONY: FORCE
FORCE:
