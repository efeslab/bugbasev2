source: https://www.securityfocus.com/bid/11991/info

NASM is prone to a buffer overflow. This condition is exposed when the application attempts to assemble a source file that contains malformed '%error' preprocessor directive arguments. Since the source file may originate from an external or untrusted source, this vulnerability is considered remote in nature.

Successful exploitation will permit arbitrary code execution with the privileges of the user running the application. 

https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/25005.zip

### Build
```
mkdir nasm
tar xf xxx.tar.gz -C nasm
cd nasm
autoconf
CC=wllvm CFLAGS='-g -O0' ./configure
make
# trigger crash
./nasm poc.S
```
### klee record & replay
see klee-record.sh, klee-replay.sh

### Data Recording
You will encounter ambiguous memory address if you enable 'oob-check'.
Thus, 'oob-check' must be enabled in the replay, otherwise you will not get an
input following the same recorded control-flow.

If you disable 'oob-check' during the first symbolic replay:
  1. With oracle ktest, replay will terminate due to adding false constraints.
  2. Without oracle ktest, replay will terminate at a similar location of where
     record terminates. However, since we silently added false constraints and
     the whole constraints are too complex, solver will not generate an
     assignment within reasonable time (solver never returns in my case).

If you enable 'oob-check' during the first symbolic replay:
klee has to fork in the memory model because multiple memory objects are involed
in one memory access.  To avoid such expensive fork, you need to do data
recording.
  1. If I manually select one instruction (see datarec.cfg, but that was based
     on global instruction unique id, not directly referenceable), then nasm can
     be fully replayed after recording 2k+ bytes (all effective). The data
     recording basically records pointers of every node in a linked-list.
  2. If I use graph analysis + first occurance binding, then I need two more
     iterations to concretize all ambiguous memory access. (see subdir
     firstoccur)
  3. If I use graph analysis + last occurance binding, I should achieve the same
     effect as manually selection (one iteration + 2K bytes). (see subdir
     lastoccur)
