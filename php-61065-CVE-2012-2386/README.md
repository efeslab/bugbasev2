# [bug 61065](https://bugs.php.net/bug.php?id=61065)
- behavior: segmentation fault
- description: use specially crafted TAR file to make the length of filename out of the range of integer(integer overflow), then parse this TAR file with the Phar extension of PHP
- sketch: 

    - `phar_parse_tarfile` at ext/phar/tar.c:342

        A filename consisted of `0xffffffff` of 'a's is crafted purposefully in *poc.phar.tar*.

        `entry.filename_len = entry.uncompressed_filesize;`

        Here, `filename_len` is `0xffffffff`.

        `entry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);`

        Obviously, this line of code is supposed to allocate memory in heap for `filename` to be stored. However, since `entry.filename+len` already reaches the integer maximum, integer overflow happened and `pemalloc` would allocate 0 byte memory to `entry.filename`(0x5555561b6cd8).

        `read = php_stream_read(fp, entry.filename, entry.filename_len);`

        This line of code should serve to read `entry.filename_len` bytes from stream `fp` to `entry.filename`.

        - `_php_stream_read` at main/streams/streams.c:590

            ```C
            if (stream->writepos > stream->readpos) {

                toread = stream->writepos - stream->readpos;
                if (toread > size) {
                    toread = size;
                }

                memcpy(buf, stream->readbuf + stream->readpos, toread);
                stream->readpos += toread;
                size -= toread;
                buf += toread;
                didread += toread;
            }
            ```

            Here, `memcpy` serves to drain the remainder of the buffer, and dump into `entry.filename`. Nevertheless, as shown above, `entry.filename` is allocated 0 byte memory, which means that this `memcpy` actually causes a heap buffer overflow, *i.e.* overwrite memory allocated not for `filename` with a series of character 'a'(61 in hex). Note that this could also be a security problem considering injection of malicious code instead of a series of character.

    - `zend_mm_search_large_block` at Zend/zend_alloc.c:1803

        ```C
        while ((p = p->child[p->child[0] != NULL)) {
            if (ZEND_MM_FREE_BLOCK_SIZE(p) < ZEND_MM_FREE_BLOCK_SIZE(best_fit)) {
                best_fit = p;
            }
        }
        ```

        in which `#define ZEND_MM_FREE_BLOCK_SIZE(b) b->info._size`

        This code snippet serves to find smallest "large" free block by traversing a tree of free block. As for the iteration in which segmentation fault happens, `p = 0x6161616161616161` and the attempt to access `p->info` failed since `p` is an invalid address. The pattern of `p` matches the heap overflow mentioned above. Besides, in the last but one iteration, `p = 0x5555561b6cd8` which is the exactly same address that overflow happened. *(struct _zend_mm_free_block *) 0x5555561b6cd8 = {info = {_cookie = 7016996765293437281, _size = 7016996765293437281, _prev = 7016996765293437281}, magic = 1633771873, prev_free_block = 0x6161616161616161, next_free_block = 0x6161616161616161, parent = 0x6161616161616161, child = {0x6161616161616161, 0x6161616161616161}}

- patch: [Check filename length not the integer max before pemalloc](http://git.php.net/?p=php-src.git;a=blobdiff;f=ext/phar/tar.c;h=b914db129eca4ee96c62bb3715cd92dcbbb3b5f4;hp=9d1e5bcb1d2f0b271deb4688615112641f5e7312;hb=a10e778bfb7ce9caa1f91666ddf2705db7982d68;hpb=63401268db9cf9b0e07b7a5819644d61f572746a)

## For new assertion (vassert) use case: apply `new_assertions.patch`
This bug is relatively easy and the added assertion should be pretty close to
the failure.
